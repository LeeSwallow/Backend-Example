<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>채팅</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
</head>
<body>
<div class="container py-4">
  <div class="d-flex justify-content-between align-items-center mb-3">
    <h2 class="m-0">채팅</h2>
    <div>
      <a class="btn btn-outline-secondary" href="/index.html">대시보드로</a>
    </div>
  </div>

  <div class="row g-4">
    <div class="col-12 col-lg-4">
      <div class="card shadow-sm">
        <div class="card-body">
          <h5 class="card-title">방 정보</h5>
          <div class="vstack gap-2 small">
            <div><span class="text-muted">Room ID:</span> <code id="roomIdText"></code></div>
            <div><span class="text-muted">Me:</span> <span id="meText"></span></div>
            <div class="d-grid">
              <button id="connectBtn" class="btn btn-primary">연결하기</button>
            </div>
          </div>
        </div>
      </div>

      <div class="card shadow-sm mt-3">
        <div class="card-body">
          <h5 class="card-title">멤버</h5>
          <ul id="members" class="list-group list-group-flush small"></ul>
        </div>
      </div>
    </div>

    <div class="col-12 col-lg-8">
      <div class="card shadow-sm">
        <div class="card-body">
          <h5 class="card-title">메시지</h5>
          <div id="messages" class="border rounded p-2 mb-3" style="height: 400px; overflow: auto; background: #fafafa"></div>
          <form id="sendForm" class="input-group">
            <input id="messageInput" type="text" class="form-control" placeholder="메시지를 입력하세요" />
            <button class="btn btn-primary" type="submit">전송</button>
          </form>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
<script>
  const params = new URLSearchParams(location.search);
  const roomId = params.get('roomId');
  const userId = params.get('userId');
  const nickname = params.get('nickname');

  const endpoints = {
    ws: '/ws/chat',
    // WebSocketConfig: applicationDestinationPrefixes('/app'), simpleBroker('/topic')
    // SubscribeMapping은 '/app/...' 으로 구독해야 1회 응답을 받습니다.
    appPrefix: '/app/chats',
    topicPrefix: '/topic/chats'
  };

  const el = {
    roomIdText: document.getElementById('roomIdText'),
    meText: document.getElementById('meText'),
    connectBtn: document.getElementById('connectBtn'),
    members: document.getElementById('members'),
    messages: document.getElementById('messages'),
    sendForm: document.getElementById('sendForm'),
    messageInput: document.getElementById('messageInput')
  };

  el.roomIdText.textContent = roomId;
  el.meText.textContent = `${nickname} (${userId})`;

  let stompClient = null;
  let connected = false;
  const membersState = new Map(); // userId -> nickname

  function connect() {
    if (connected) return;
    const sock = new SockJS(endpoints.ws);
    stompClient = Stomp.over(sock);
    stompClient.debug = null; // 콘솔 로그 끄기

    stompClient.connect({}, async () => {
      connected = true;
      el.connectBtn.classList.replace('btn-primary', 'btn-outline-secondary');
      el.connectBtn.textContent = '연결됨';
      el.connectBtn.disabled = true;

      // 초기 데이터 구독 (SubscribeMapping 응답)
      stompClient.subscribe(`${endpoints.appPrefix}/${roomId}`, (frame) => {
        const history = JSON.parse(frame.body);
        history.forEach(appendMessage);
        scrollToBottom();
      });
      stompClient.subscribe(`${endpoints.appPrefix}/${roomId}/members`, (frame) => {
        const list = JSON.parse(frame.body);
        setMembers(list);
        renderMembers();
      });

      // 실시간 브로드캐스트 구독 (컨트롤러의 @SendTo)
      stompClient.subscribe(`${endpoints.topicPrefix}/${roomId}`, (frame) => {
        const payload = JSON.parse(frame.body);
        // ChatMessageDto or UserActionDto 구분
        if (payload && typeof payload.content === 'string') {
          appendMessage(payload);
          scrollToBottom();
        }
      });

      // 멤버 이벤트 실시간 구독
      stompClient.subscribe(`${endpoints.topicPrefix}/${roomId}/members`, (frame) => {
        const evt = JSON.parse(frame.body); // UserActionDto
        if (evt && evt.userInfo && evt.action) {
          const { id, nickname } = evt.userInfo;
          if (evt.action === 'ENTER') {
            membersState.set(id, nickname);
          } else if (evt.action === 'LEAVE') {
            membersState.delete(id);
          }
          renderMembers();
        }
      });

      // 입장 이벤트 전송 (구독이 모두 완료된 뒤 전송)
      stompClient.send(`${endpoints.appPrefix}/${roomId}/enter`, {}, JSON.stringify({ id: userId, nickname }));

      // 안전장치: 간헐적으로 초기 멤버 이벤트를 놓칠 수 있으므로 잠시 뒤 멤버 목록을 한 번 더 요청
      setTimeout(() => {
        stompClient.subscribe(`${endpoints.appPrefix}/${roomId}/members`, (frame) => {
          const list = JSON.parse(frame.body);
          setMembers(list);
          renderMembers();
        });
      }, 300);
    });
  }

  function appendMessage(m) {
    const div = document.createElement('div');
    div.className = 'mb-1';
    const nick = m.nickname || '익명';
    const content = escapeHtml(m.content || '');
    div.innerHTML = `<span class="fw-semibold">${nick}</span>: ${content}`;
    el.messages.appendChild(div);
  }

  function setMembers(list) {
    membersState.clear();
    list.forEach(u => membersState.set(u.id, u.nickname));
  }

  function renderMembers() {
    el.members.innerHTML = '';
    Array.from(membersState.entries()).forEach(([id, nick]) => {
      const li = document.createElement('li');
      li.className = 'list-group-item';
      li.textContent = `${nick} (${id})`;
      el.members.appendChild(li);
    });
  }

  function sendMessage(content) {
    if (!connected || !content.trim()) return;
    stompClient.send(`${endpoints.appPrefix}/${roomId}/send`, {}, JSON.stringify({
      id: null,
      senderId: userId,
      nickname,
      content,
      sentAt: null
    }));
  }

  function leave() {
    if (!connected) return;
    stompClient.send(`${endpoints.appPrefix}/${roomId}/leave`, {}, JSON.stringify({ id: userId, nickname }));
    stompClient.disconnect(() => {
      connected = false;
    });
  }

  function scrollToBottom() {
    el.messages.scrollTop = el.messages.scrollHeight;
  }

  function escapeHtml(str) {
    return (str || '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  window.addEventListener('beforeunload', leave);

  el.sendForm.addEventListener('submit', (ev) => {
    ev.preventDefault();
    const text = el.messageInput.value;
    sendMessage(text);
    el.messageInput.value = '';
    el.messageInput.focus();
  });

  el.connectBtn.addEventListener('click', connect);
  // 자동 연결을 원하면 아래 주석 해제
  // connect();
</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>


